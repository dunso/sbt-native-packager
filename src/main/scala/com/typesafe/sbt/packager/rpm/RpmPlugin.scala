package com.typesafe.sbt.packager.rpm

import sbt._
import sbt.Keys._
import java.nio.charset.Charset

import com.typesafe.sbt.SbtNativePackager.Linux
import com.typesafe.sbt.packager.SettingsHelper
import com.typesafe.sbt.packager.Keys._
import com.typesafe.sbt.packager.linux._
import com.typesafe.sbt.packager.Compat._
import com.typesafe.sbt.packager.validation._

/**
  * Plugin containing all generic values used for packaging rpms.
  *
  * @example Enable the plugin in the `build.sbt`
  * {{{
  *    enablePlugins(RpmPlugin)
  * }}}
  */
object RpmPlugin extends AutoPlugin {

  override def requires = LinuxPlugin

  object autoImport extends RpmKeys {
    val Rpm: Configuration = config("rpm") extend Linux
    val RpmConstants = Names
  }

  import autoImport._

  private final def osPostInstallMacro: java.net.URL =
    getClass getResource "brpJavaRepackJar"

  /** RPM specific names */
  object Names {
    val Scriptlets = "scriptlets"

    //maintainer script names
    /** `pretrans` */
    val Pretrans = "pretrans"

    /** `postinst` */
    val Post = "post"

    /** `preinst` */
    val Pre = "pre"

    /** `postun` */
    val Postun = "postun"

    /** `preun` */
    val Preun = "preun"

    /** `verifyscript` */
    val Verifyscript = "verifyscript"

    /** `posttrans` */
    val Posttrans = "posttrans"

  }

  override def projectConfigurations: Seq[Configuration] = Seq(Rpm)

  override lazy val projectSettings = Seq(
    rpmOs := "Linux", // TODO - default to something else?

    //- The release number is the packageâ€™s version.
    //- When the sofware is first packaged at a particular version, the release should be "1".
    //- If the software is repackaged at the same version,
    //- the release number should be incremented, and dropped back to "1" when the software version is new. I
    rpmRelease := (if (isSnapshot.value) "SNAPSHOT" else "1"),
    rpmPrefix := None,

    //- The name of the company/user generating the RPM.
    rpmVendor := "", // TODO - Maybe pull in organization?

    //- The license associated with software in the RPM.
    rpmLicense := None,
    rpmDistribution := None,

    //- A url associated with the software in the RPM.
    rpmUrl := None,
    rpmGroup := None,
    rpmPackager := None,
    rpmIcon := None,
    rpmAutoprov := "yes",
    rpmAutoreq := "yes",
    rpmProvides := Seq.empty,
    rpmRequirements := Seq.empty,
    rpmPrerequisites := Seq.empty,
    rpmObsoletes := Seq.empty,
    rpmConflicts := Seq.empty,
    rpmSetarch := None,
    rpmChangelogFile := None,

    //- appends __os_install_post scriptlet to rpmPre avoiding jar repackaging
    rpmBrpJavaRepackJars := false,
    rpmPretrans := None,
    rpmPre := None,
    rpmPost := None,
    rpmVerifyscript := None,
    rpmPosttrans := None,
    rpmPreun := None,
    rpmPostun := None,
    rpmScriptsDirectory := sourceDirectory.value / "rpm" / Names.Scriptlets,



    // Explicitly defer  default settings to generic Linux Settings.
    //- Contains the scriptlets being injected into the specs file.
    //- Currently supports all previous scriptlets: %pretrans, %pre, %verifyscript%, %post, %posttrans, %preun and %postun
    maintainerScripts in Rpm := (maintainerScripts in Linux).value,

    //- A brief, one-line summary of the package.
    //- Note: the summary must not contain line separators or end in a period.
    //- Its value defines the Summary: tag in the spec file, and its default value is drawn from packageSummary in Linux.
    packageSummary in Rpm := (packageSummary in Linux).value,

    //- A longer, multi-line description of the package.
    //- Its value defines the %description block in the spec file, and its default value is drawn from packageDescription in Linux.
    packageDescription in Rpm := (packageDescription in Linux).value,
    target in Rpm := target.value / "rpm",
    name in Rpm := (name in Linux).value,

    //- The name of the package for the rpm. Its value defines the first component of the rpm file name
    //- packageName-version-rpmRelease.packageArchitecture.rpm
    packageName in Rpm := (packageName in Linux).value,
    executableScriptName in Rpm := (executableScriptName in Linux).value,

    //- File name of the log generated by application daemon.
    rpmDaemonLogFile := s"${(packageName in Linux).value}.log",
    daemonStdoutLogFile in Rpm := Some(rpmDaemonLogFile.value),
    validatePackageValidators in Rpm := Seq(
      nonEmptyMappings((linuxPackageMappings in Rpm).value.flatMap(_.mappings)),
      filesExist((linuxPackageMappings in Rpm).value.flatMap(_.mappings)),
      checkMaintainer((maintainer in Rpm).value, asWarning = false)
    ),
    // override the linux sourceDirectory setting
    sourceDirectory in Rpm := sourceDirectory.value,


    //- The build architecture for the binary rpm.
    //- Its value defines the fourth component of the rpm file name (packageName-version-rpmRelease.packageArchitecture.rpm),
    // as well as the BuildArch: tag in the spec file. Its default value is "noarch".
    packageArchitecture in Rpm := "noarch",


    rpmMetadata := RpmMetadata(
      (packageName in Rpm).value,

      //- The version of the package for rpm.
      //- Takes the form x.y.z, and note that there can be no dashes in this version string.
      //- It defines the second component of the rpm file name
      //- packageName-version-rpmRelease.packageArchitecture.rpm
      (version in Rpm).value.stripSuffix("-SNAPSHOT"),
      rpmRelease.value,
      rpmPrefix.value,
      (packageArchitecture in Rpm).value,
      rpmVendor.value,
      rpmOs.value,
      (packageSummary in Rpm).value,
      (packageDescription in Rpm).value,
      rpmAutoprov.value,
      rpmAutoreq.value
    ),
    rpmDescription := RpmDescription(
      rpmLicense.value,
      rpmDistribution.value,
      rpmUrl.value,
      rpmGroup.value,
      rpmPackager.value,
      rpmIcon.value,
      rpmChangelogFile.value
    ),
    rpmDependencies := RpmDependencies(
      rpmProvides.value,
      rpmRequirements.value,
      rpmPrerequisites.value,
      rpmObsoletes.value,
      rpmConflicts.value
    ),
    maintainerScripts in Rpm := {
      val scripts = (maintainerScripts in Rpm).value
      if (!rpmBrpJavaRepackJars.value) {
        val pre = scripts.getOrElse(Names.Pre, Nil)
        val scriptBits = IO.readStream(RpmPlugin.osPostInstallMacro.openStream, Charset forName "UTF-8")
        scripts + (Names.Pre -> (pre :+ scriptBits))
      } else {
        scripts
      }
    },
    rpmScripts := RpmScripts
      .fromMaintainerScripts((maintainerScripts in Rpm).value, (linuxScriptReplacements in Rpm).value),
    rpmSpecConfig := RpmSpec(
      rpmMetadata.value,
      rpmDescription.value,
      rpmDependencies.value,
      rpmSetarch.value,
      rpmScripts.value,
      (linuxPackageMappings in Rpm).value,
      (linuxPackageSymlinks in Rpm).value,
      (defaultLinuxInstallLocation in Rpm).value
    ),
    stage in Rpm := RpmHelper.stage(rpmSpecConfig.value, (target in Rpm).value, streams.value.log),

    //- Generates the .rpm package for this project.
    packageBin in Rpm := RpmHelper.buildRpm(rpmSpecConfig.value, (stage in Rpm).value, streams.value.log),

    //- Generates the .rpm file and runs the rpmlint command to look for issues in the package. Useful for debugging.
    rpmLint := {
      sys.process.Process(Seq("rpmlint", "-v", (packageBin in Rpm).value.getAbsolutePath)) ! streams.value.log match {
        case 0 => ()
        case x => sys.error("Failed to run rpmlint, exit status: " + x)
      }
    }
  )
}

object RpmDeployPlugin extends AutoPlugin {

  import RpmPlugin.autoImport._

  override def requires = RpmPlugin

  override def projectSettings: Seq[Setting[_]] =
    SettingsHelper.makeDeploymentSettings(Rpm, packageBin in Rpm, "rpm")
}
